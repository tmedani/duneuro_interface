% Teste les fonction de calculs du potentiels: verification des résultats
% et comparaison avec les code de BST et OpenMEEG et mon code (isotrope)
%% f1: om_spher_pot_aniso : fonction de OpenMEEG pour calculer le potentiel
% analytique dans un modéle de tête sphérique avec conductivité
% anisotropique
%
% Calculates the electrical potential at point x on the surface of a layered
% conductive sphere induced by a current dipole of strength q at point
% p. The radii of the spheres are given by a vector rk in ascending order,
% the radial (resp. tangential) conductivities are in sigmas (resp. xis) SI units.
% The norm of x must be equal to the last rk.
%
% Usage: u=om_spher_pot_aniso(x,q,p,sigmas,xis,rk) ;
%
% All vectors (x,q,p) should be in 3D.
%% f2: om_spher_pot_iso : fonction de OpenMEEG pour calculer le potentiel
% analytique dans un modéle de tête sphérique avec conductivité
% isotropique :  u = om_spher_pot_iso(x,q,p,sigmas,rk)
% Calculates the electrical potential at point x on the surface of a layered
% conductive sphere induced by a current dipole of strength q at point
% p. The radii of the spheres are given by a vector rk in ascending order,
% the corresponding conductivities are in sigmas. SI units.
% The norm of x must be equal to the last rk.
%
% Usage: u = om_spher_pot_iso(x,q,p,sigmas,rk);



%% f3 : bst_eeg_sph : fontion de BrainStorm pour la solution analytique
% G = bst_eeg_sph(Rq, Re, center, R, sigma)
% Vbst=G*[dx dy dz]'; % methode utilisé dans ce code
% Utilisation de la fonction de Matlab pour contraindre la solution
% Vbst_cst=bst_gain_orient(G,[dx dy dz]); % Cette ligne fait la même chose que la ligne precedente, elle donne la solution constrainte. 
% BST_EEG_SPH: Calculate the electric potential, spherical head, arbitrary orientation
%
% USAGE:  G = bst_eeg_sph(Rq, Channel, center, R, sigma);
%
% INPUT:
%    - Rq     : dipole location(in meters)    [nDipoles x 3]
%    - Re     : EEG sensors(in meters)        [nSensors x 3]  
%    - center : Sphere center                 [1 x 3]
%    - R      : radii(in meters) of sphere from INNERMOST to OUTERMOST  [nLayers x 1]
%    - sigma  : conductivity from INNERMOST to OUTERMOST                [nLayers x 1]
%
% OUTPUTS:
%    - G : EEG forward model gain matrix    [nSensors x (3*nDipoles)]
%
% DESCRIPTION:  EEG multilayer spherical forward model
%     This function computes the voltage potential forward gain matrix for an array of 
%     EEG electrodes on the outermost layer of a single/multilayer conductive sphere. 
%     Each region of the multilayer sphere is assumed to be concentric with 
%     isontropic conductivity.  EEG sensors are assumed to be located on the surface
%     of the outermost sphere. 
% 
%     Method: Series Approximiation of a Multilayer Sphere as three dipoles in a 
%             single shell using "Berg/Sherg" parameter approximation.
%     Ref:    Z. Zhang "A fast method to compute surface potentials generated by 
%             dipoles within multilayer anisotropic spheres" 
%             (Phys. Med. Biol. 40, pp335-349,1995)    
% 
%     Dipole generator(s) are assumed to be interior to the innermost "core" layer. For those 
%     dipoles external to the sphere, the dipole "image" is computed and used determine the 
%     gain function. The exception to this is the Legendre Method where all dipoles MUST be 
%     interior to the innermost "core" layer.

clc;close all;clear all;clc
cd('G:\My Drive\GitFolders\GitHub\brainstorm-duneuro\matlab_codes\Mesh_generation\BasedOnRoast_Takfa\bst_integration')

% https://www.researchgate.net/publication/296790520_Modelisation_of_inhomogeneous_and_anisotropic_conductivities_in_a_realistic_head_model_for_the_EEG_and_MEG_forward_problem

%% Creation du maillage de la sphére:
c0=[0,0,0];
r=0.1;
tsize=r/10;
maxvol=r/10;
%% sphere 1
r1=0.065;
[node1,face1,elem1]=meshasphere(c0,r1,tsize,maxvol);
%figure;plotmesh(node1,face1,elem1,'x<0');grid;xlabel('x');ylabel('y');zlabel('z');
surf1=volface(elem1);[nf1,ff1]=removeisolatednode(node1,surf1);
%figure;plotmesh(nf1,ff1,'x<0');grid;xlabel('x');ylabel('y');zlabel('z');

%% sphere 2
r2=0.071;
[node2,face2,elem2]=meshasphere(c0,r2,tsize,maxvol);
%figure;plotmesh(node2,face2,elem2,'x<0');grid;xlabel('x');ylabel('y');zlabel('z');
surf2=volface(elem2);[nf2,ff2]=removeisolatednode(node2,surf2);
%figure;plotmesh(nf2,ff2,'x<0');grid;xlabel('x');ylabel('y');zlabel('z');

%% sphere 3
r3=0.075;
[node3,face3,elem3]=meshasphere(c0,r3,tsize,maxvol);
%figure;plotmesh(node3,face3,elem3,'x<0');grid;xlabel('x');ylabel('y');zlabel('z');
surf3=volface(elem3);[nf3,ff3]=removeisolatednode(node3,surf3);
%figure;plotmesh(nf3,ff3,'x<0');grid;xlabel('x');ylabel('y');zlabel('z');

%% sphere 3
r4=0.080;
[node4,face4,elem4]=meshasphere(c0,r4,tsize,maxvol);
%figure;plotmesh(node3,face3,elem3,'x<0');grid;xlabel('x');ylabel('y');zlabel('z');
surf4=volface(elem4);[nf4,ff4]=removeisolatednode(node4,surf4);
%figure;plotmesh(nf3,ff3,'x<0');grid;xlabel('x');ylabel('y');zlabel('z');


%% Assemblage des spheres
[noeuds, faces]=mergemesh(nf1,ff1,nf2,ff2,nf3,ff3,nf4,ff4);
%figure;plotmesh(noeuds, faces,'x<0');grid;xlabel('x');ylabel('y');zlabel('z');
%% Generate volume mesh 
% Find the seed point for each region
center_inner = c0;
newnode = noeuds;
newelem = faces;
%% define seeds along the electrode axis
orig = center_inner;
v0= [0 0 1];
[t,baryu,baryv,faceidx]=raytrace(orig,v0,newnode,newelem);
t=sort(t(faceidx));
t=(t(1:end-1)+t(2:end))*0.5;
seedlen=length(t);
seeds=repmat(orig(:)',seedlen,1)+repmat(v0(:)',seedlen,1).*repmat(t(:),1,3);

%% Generate the volume Mesh
% Generate volume mesh
factor_bst = 1.e-6;
maxvol = 0.01; 
keepratio = 0.8;
regions = seeds;% [seedRegion1;seedRegion2;seedRegion3];
% The order is important, the output label will be related to this order,
% which is related to the conductivity value.
clear node elem face;
[node,elem,face]=surf2mesh(newnode,newelem,...
                                                min(newnode),max(newnode),...
                                                keepratio,maxvol*factor_bst,regions,[]);                                        
                                         
 elemID = unique(elem(:,5));

figure;
col = ['w','b','g','r'];
elemID = unique(elem(:,5));
for ind = 1 : length(elemID)
plotmesh(node,elem((elem(:,5)==elemID(ind)),:) ,'y>0','facecolor',col(ind));
hold on;
%grid on; grid minor;
% update the element ID to the original 
elem((elem(:,5)==elemID(ind)),5)  = (ind);
end
legend({'WM','CSF','Skull','Scalp'})
hold on

% Extract surfaces nodes
 [openface,elemid]=volface(elem(:,1:4));
 [no,el]=removeisolatednode(node,openface);
figure; plotmesh(no,el,'x>0')
elec = no(randperm(length(no),32),:);
%%
Rq=[0 0 0]+1.e-10; %position de la source
Re=elec;%noeuds; % position de l'ectrode
center=c0+1.e-10;  % positiondu centre
sigma=[0.33 1 0.0042 0.33];% conductivité isotropic

x=Re;% position de point de calcul, electrode ou noeud en 3D x,y,z
q=[0,1,0];% strength of the moment dipole (moment en 3D mx,my,mz)
p=Rq; %position de la source en 3D x,y,z 
sigmas=sigma; % radial conductivities of layers
skull_factor = 1;
wm_factor = 1;
xis=[wm_factor*0.33 1 0.0042*skull_factor 0.33]; % tangential conductivities of layers
rk=[r1 r2 r3 r4]; % rayon des sphére dans l'ordre croissant % The radii of the spheres are given by a vector rk in ascending order

clear u1 u2 u3;close all;clc

%% f1 solution anisotrop
u1=om_spher_pot_aniso(x,q,p,sigmas,xis,rk) ;

%figure;plotmesh([noeuds u1], faces,'x<0')

%%f2 solution isotrop
u2 = om_spher_pot_iso(x,q,p,sigmas,rk);
%figure;plotmesh([noeuds u2], faces,'x<0')

%% f3
R=rk;
Rq=[0 0 0];
G = bst_eeg_sph(Rq, Re, center, R, sigma);
u3=G*q';
%figure;plotmesh([noeuds u3], faces,'x<0')

figure;plot(u1,'ro');hold on;plot(u2,'bx');hold on;plot(u3,'ks');legend('OM ANI','OM ISO','BST ISO');grid;
figure;plot(zscore(u1),'ro');hold on;plot(zscore(u2),'bx');hold on;plot(zscore(u3),'ks');legend('OM ANI','OM ISO','BST ISO');grid;

outPutFolder = 'test_aniso';
mkdir(outPutFolder)
cd(outPutFolder)

%% Test the Finite elements method : 
%% 1.2- Write the mesh in the 'msh' format (input for duneuro)
% my function corrected with Tim
head_filename = 'test_aniso_sphere.msh';
Vn = zeros(1,length(node)); nnode = [(1:length(node))' node];nelem = [(1:length(elem))' elem];
fc_ecriture_fichier_msh(nnode,nelem,Vn,head_filename);
%%  2- The Source Model
% Write the source/dipole file
dipole_filename = 'dipole_model.txt'; 
dipoles_pos = Rq;% source location
write_duneuro_dipole_file(dipoles_pos,dipole_filename);

%% 3- The electrode Model
electrode_filename = 'electrode_model.txt'; 
% Channel location :
write_duneuro_electrode_file(Re, electrode_filename);
%% 4 - The Conductivity Model
cond_filename = 'conductivity_model.con'; 
write_duneuro_conductivity_file(sigma,cond_filename)

%% 5 Build the file that could be stored in the bst data base
vol.pos = nnode(:,2:end); 
vol.tet = elem(:,1:4);
vol.hex = [];
vol.tissue = elem(:,end);
vol.cond = sigma;
vol.tissuelabel = {'WM','CSF','Skull','Scalp'};
vol.unit = 'm';
%% 5.1 Set mini file parameter /configuration
% put all the paramater in the cfg structure
vol.cfg.head_filename = head_filename;
vol.cfg.dipole_filename = dipole_filename;
vol.cfg.electrode_filename = electrode_filename;
vol.cfg.cond_filename = cond_filename;
%%%% ===> this step should be modified from the bst gui
vol = set_minifile(vol);
% 5.2 Write the mini file and the vol structure
mini_filename = 'model_minifile.mini';
write_duneuro_minifile(vol, mini_filename);

%% 6 run the EEG forward problem & compute the lead field
cmd = 'bst_eeg_transfer.exe';
arg = mini_filename;
 %  run the system
if ~isfile('Vfem-transfert.txt')
tic;
system([cmd ' '  arg])
t1 = toc;
temp = load('Vfem-transfert_gmsh.txt');
end

figure;plot(u1,'ro');hold on;plot(u2,'bx');hold on;plot(u3,'ks');hold on;plot(temp(2,:),'g*');
legend('OM ANI','OM ISO','BST ISO','DNISO');grid;

figure;plot(zscore(u1),'ro');hold on;plot(zscore(u2),'bx');hold on;plot(zscore(u3),'ks');hold on;plot(zscore(temp(2,:)),'g*');
legend('OM ANI','OM ISO','BST ISO','DNISO');grid;
%% test anisotropy
% test the Cauchy files 
% load the model : 
% model_name = 'mesh_8246.mat'; % mesh_5871,mesh_8246
% load(model_name)

%node = model.volume.node;
%elem = model.volume.elem;
% write the mesh as cauchy file geometry
geofilename = 'model_aniso.geo';
bst_write_cauchy_geometry(node,elem,geofilename)

% write the conductivity as cauchy file conductivity
condfilename = 'cond_8246.knw';
conductivity_scalar = sigma;
conductivity_tensor = [];
for nl = 1 : 4
conductivity_tensor(nl,:) = [sigma(nl) sigma(nl) sigma(nl) 0 0 0];
end
conductivity_tensor(3,:) = [sigma(3) /skull_factor sigma(3) sigma(3)/skull_factor 0 0 0];

%bst_write_cauchy_scalar_conductivity(elem,conductivity_scalar,condfilename)
bst_write_cauchy_tensor_conductivity(elem,conductivity_tensor,condfilename)
tic;
system([cmd  ' model_minifile_cauchy.mini'])
t_transfer = toc;
temp2 = load('Vfem-transfert_geo.txt');


figure;
plot(zscore(temp(2,:)),'ro');
hold on;
plot(zscore(temp2(2,:)),'bx');
legend('msh','geo');grid;


figure;plot(zscore(u1),'ro');hold on;plot(zscore(u2),'bx');hold on;plot(zscore(u3),'ks');hold on;plot(zscore(temp(2,:)),'g*');hold on;plot(zscore(temp2(2,:)),'c>');
legend('OM ANI','OM ISO','BST ISO','DN msh','DN geo');grid;


%% Add test anisotropy for the Duneuro : 
% generate tensore for each layers inside the skull for example and test
% aith the analytical solution
%% Extract layer of interest 
% skull ID =3 
elemID
tissu_id = 3;
tissu_elem = elem(elem(:,5)==tissu_id,:);
tissu_elem = elem(:,1:4);
[no,el]=removeisolatednode(node,tissu_elem);
figure;plotmesh(no,el,'x>0');

no = cfg.node; el = cfg.elem;
figure;plotmesh(no,el,'x>0');
%% compute the centroide of each element :
 x= reshape(no(el(:,1:4),:),4,[]);
 
 el_centroide = meshCentroid(no,el);

%figure;plotmesh(no,el,'x>0','facealpha',0.5);  hold on;plotmesh(el_centroide,'x>0','r.')
figure;plotmesh(no,el(1:4,:),'facealpha',0.5);  hold on;plotmesh(el_centroide(1:4,:),'rx')

%% Compute the vectore from the center to the centroide: 
clear vector_norm_centroid vector_centroid Endpoint Startpoint
Startpoint = c0;
Endpoint = el_centroide;
vector_centroid = Endpoint - Startpoint;
vector_norm_centroid = vector_centroid./sqrt(vector_centroid(:,1).^2+vector_centroid(:,2).^2+vector_centroid(:,3).^2); % vector with length 1
figure;plotmesh(no,el,'x>0','facealpha',0.5);  hold on;plotmesh(el_centroide,'x>0','r.')
hold on; quiver3(el_centroide(:,1),el_centroide(:,2),el_centroide(:,3),vector_norm_centroid(:,1),vector_norm_centroid(:,2),vector_norm_centroid(:,3))

num_view = 1:2;
figure;plotmesh(no,el(num_view,:),'facealpha',0.5);  hold on;plotmesh(el_centroide(num_view,:),'rx')
hold on; quiver3(el_centroide(num_view,1),el_centroide(num_view,2),el_centroide(num_view,3),vector_norm_centroid(num_view,1),vector_norm_centroid(num_view,2),vector_norm_centroid(num_view,3))

% compute the tangential vector
for ind = 1 : length(vector_norm_centroid)
r1= vector_norm_centroid(ind,:);
r = null(r1(:).');
vector_norm_centroid_t1(ind,:) = r(:,1)';
vector_norm_centroid_t2(ind,:) =r(:,2)';
end
% check the length
sqrt(vector_norm_centroid(:,1).^2+vector_norm_centroid(:,2).^2+vector_norm_centroid(:,3).^2)
sqrt(vector_norm_centroid_t1(:,1).^2+vector_norm_centroid_t1(:,2).^2+vector_norm_centroid_t1(:,3).^2)
sqrt(vector_norm_centroid_t2(:,1).^2+vector_norm_centroid_t2(:,2).^2+vector_norm_centroid_t2(:,3).^2)

% check scallar products
A = vector_norm_centroid_t1;
B = vector_norm_centroid_t1;
dotP = dot(A,B,2);max(dotP)

% check the view
num_view = 1:2;
figure;plotmesh(no,el(num_view,:),'facealpha',0.5);  hold on;plotmesh(el_centroide(num_view,:),'rx')
hold on; quiver3(el_centroide(num_view,1),el_centroide(num_view,2),el_centroide(num_view,3),vector_norm_centroid(num_view,1),vector_norm_centroid(num_view,2),vector_norm_centroid(num_view,3))
hold on; quiver3(el_centroide(num_view,1),el_centroide(num_view,2),el_centroide(num_view,3),vector_norm_centroid_t1(num_view,1),vector_norm_centroid_t1(num_view,2),vector_norm_centroid_t1(num_view,3))
hold on; quiver3(el_centroide(num_view,1),el_centroide(num_view,2),el_centroide(num_view,3),vector_norm_centroid_t2(num_view,1),vector_norm_centroid_t2(num_view,2),vector_norm_centroid_t2(num_view,3))
legend('elem','centr','Vr','Vt1','Vt2')


%% compute the tensor :
sigmas; xis;
cond = [sigmas;xis];
%A = diag([sigmas(3),xis(3), xis(3)]);
%A = diag([sigmas(3),sigmas(3), sigmas(3)]);

for ind = 1:length(elemID)
% A(:,:,ind) = diag([sigmas(ind),xis(ind), xis(ind)]);
A(:,:,ind) = diag([sigmas(ind),sigmas(ind), sigmas(ind)]);
end
%% Transformation matrix 
%T1 = [vector_norm_centroid(1,:)' vector_norm_centroid_t1(1,:)' vector_norm_centroid_t2(1,:)'];
% temp = T1 * A * T1';
% tensor  = [temp(1) temp(5) temp(9) temp(4) temp(7) temp(8)]

for ind =1 : length(vector_norm_centroid)
    T1 = [vector_norm_centroid(ind,:)' vector_norm_centroid_t1(ind,:)' vector_norm_centroid_t2(ind,:)'];
    temp = T1 * A(:,:,elem(ind,5)) * T1';
    tensor(ind,:) = [temp(1) temp(5) temp(9) temp(4) temp(7) temp(8)];
end
check = [tensor sigmas(elem(:,5))'  elem(:,5)] ;
T1*T1';

%% write the tensor file 
condfilename = 'aniso_aniso_8246.knw';
bst_write_cauchy_tensor_conductivity(elem,abs(tensor),condfilename)
tic;
system([cmd  ' model_minifile_cauchy.mini'])
t_transfer = toc;

%% Isotropic model :
tempGeo = load('Vfem-transfert_geo.txt');
tempGmsh =  load('Vfem-transfert_gmsh.txt');

temp_anis =  load('Vfem-transfert_aniso.txt');
temp_iso =  load('Vfem-transfert_iso.txt');



figure;
plot(zscore(temp_anis(2,:)-temp_anis(2,1)),'ro');hold on;
plot(zscore(temp_iso(2,:)-temp_iso(2,1)),'c>');hold on;
plot(zscore(u1),'b*');hold on;
plot(zscore(u2),'gx');hold on;
plot(zscore(u3),'ks');

legend('DN aniso','DN iso','OM ANI','OM ISO','BST ISO');grid;




%% Anisotropic solution oth analytical in u1 and 
temp_aniso_aniso =  load('Vfem-transfert_aniso_aniso.txt');
figure;
plot(zscore(temp_aniso_aniso(2,:)-temp_aniso_aniso(2,1)),'ro');hold on;
plot(zscore(u1),'b*');hold on;legend('DN aniso','OM ANI');grid on;

legend('DN aniso','DN iso','OM ANI','OM ISO','BST ISO');grid;

plot(zscore(u2),'k>');hold on;
plot(zscore(u3),'g<');hold on;

% 
% [azimuth,elevation,r_norm] = cart2sph(vector_norm_centroid(:,1),vector_norm_centroid(:,2),vector_norm_centroid(:,3));
% [vector_norm_centroid_t1(:,1),vector_norm_centroid_t1(:,2),vector_norm_centroid_t1(:,3)] = sph2cart(azimuth,elevation+pi/2,r_norm);
% [vector_norm_centroid_t2(:,1),vector_norm_centroid_t2(:,2),vector_norm_centroid_t2(:,3)] = sph2cart(azimuth+pi/2,elevation+pi/2,r_norm);

%[azimuth,elevation,r_norm] = cart2sph(vector_norm_centroid_t1(:,1),vector_norm_centroid_t1(:,2),vector_norm_centroid_t1(:,3));
%[vector_norm_centroid_t2(:,1),vector_norm_centroid_t2(:,2),vector_norm_centroid_t2(:,3)] = sph2cart(azimuth+pi/2,elevation+pi/2,r_norm);

%% Plot triedre direct au centre du mesh
X_axis = [vector_norm_centroid(:,1) ...
               zeros(1,length(vector_norm_centroid))' ...
               zeros(1,length(vector_norm_centroid))' ];
Y_axis = [zeros(1,length(vector_norm_centroid))' ...
               vector_norm_centroid(:,2) ...
               zeros(1,length(vector_norm_centroid))' ];
Z_axis = [zeros(1,length(vector_norm_centroid))'...
               zeros(1,length(vector_norm_centroid))'...
               vector_norm_centroid(:,3) ];

num_view = 1:2;
figure;plotmesh(no,el(num_view,:),'facealpha',0.5);  hold on;plotmesh(el_centroide(num_view,:),'rx')
hold on; quiver3(el_centroide(num_view,1),el_centroide(num_view,2),el_centroide(num_view,3),X_axis(num_view,1),X_axis(num_view,2),X_axis(num_view,3))
hold on; quiver3(el_centroide(num_view,1),el_centroide(num_view,2),el_centroide(num_view,3),Y_axis(num_view,1),Y_axis(num_view,2),Y_axis(num_view,3))
hold on; quiver3(el_centroide(num_view,1),el_centroide(num_view,2),el_centroide(num_view,3),Z_axis(num_view,1),Z_axis(num_view,2),Z_axis(num_view,3))
hold on; quiver3(el_centroide(num_view,1),el_centroide(num_view,2),el_centroide(num_view,3),vector_norm_centroid(num_view,1),vector_norm_centroid(num_view,2),vector_norm_centroid(num_view,3))
xlabel('X');ylabel('Y');zlabel('Z');view(2)

%% Compute the conductivity value projected into each direction:
radial_value = sigma(tissu_id);
tangential_value = xis(tissu_id);
% skull_factor = 100;
% xis=[0.33 1 0.0042*skull_factor 0.33]; % tangential conductivities of layers
[azimuth,elevation,r_norm] = cart2sph(X_axis(:,1),X_axis(:,2),X_axis(:,3));
[Xr_axis(:,1),Xr_axis(:,2),Xr_axis(:,3)] = sph2cart(azimuth,pi/2-elevation,r_norm);

[azimuth,elevation,r_norm] = cart2sph(Y_axis(:,1),Y_axis(:,2),Y_axis(:,3));
[Yr_axis(:,1),Yr_axis(:,2),Yr_axis(:,3)] = sph2cart(azimuth,pi/2-elevation,r_norm);


[azimuth,elevation,r_norm] = cart2sph(Z_axis(:,1),Z_axis(:,2),Z_axis(:,3));
[Zr_axis(:,1),Zr_axis(:,2),Zr_axis(:,3)] = sph2cart(azimuth,pi/2-elevation,r_norm);


num_view = 1:2;
figure;plotmesh(no,el(num_view,:),'facealpha',0.5);  hold on;plotmesh(el_centroide(num_view,:),'rx')
hold on; quiver3(el_centroide(num_view,1),el_centroide(num_view,2),el_centroide(num_view,3),X_axis(num_view,1),X_axis(num_view,2),X_axis(num_view,3))
hold on; quiver3(el_centroide(num_view,1),el_centroide(num_view,2),el_centroide(num_view,3),Xr_axis(num_view,1),Xr_axis(num_view,2),Xr_axis(num_view,3),'markersize',20)

hold on; quiver3(el_centroide(num_view,1),el_centroide(num_view,2),el_centroide(num_view,3),Y_axis(num_view,1),Y_axis(num_view,2),Y_axis(num_view,3))
hold on; quiver3(el_centroide(num_view,1),el_centroide(num_view,2),el_centroide(num_view,3),Yr_axis(num_view,1),Yr_axis(num_view,2),Yr_axis(num_view,3),'markersize',20)

hold on; quiver3(el_centroide(num_view,1),el_centroide(num_view,2),el_centroide(num_view,3),Z_axis(num_view,1),Z_axis(num_view,2),Z_axis(num_view,3))
hold on; quiver3(el_centroide(num_view,1),el_centroide(num_view,2),el_centroide(num_view,3),Zr_axis(num_view,1),Zr_axis(num_view,2),Zr_axis(num_view,3),'markersize',20)
xlabel('X');ylabel('Y');zlabel('Z');view(2)


